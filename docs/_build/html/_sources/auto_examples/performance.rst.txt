
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/performance.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_performance.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_performance.py:


Performance Comparisons
========================

``bulletchess``'s creation was motivated by frustration with `python-chess <https://python-chess.readthedocs.io/en/latest/>`_'s slow performance.
``python-chess`` is a fantastic, feature-rich library, but is inherently limited in its performance by being implemented by python. ``bulletchess``, however, is implemented as a pure C-extension.
To demonstrate how much faster ``bulletchess`` is, we can write equivalent functions in both libraries, and compare the runtimes.

Perft
------

Let's start by implementing a `Perft` function. In ``bulletchess``:

.. GENERATED FROM PYTHON SOURCE LINES 15-32

.. code-block:: Python

    import bulletchess
    from bulletchess.utils import count_moves

    def bullet_perft(board : bulletchess.Board, depth : int) -> int:
        if depth == 0:
            return 1
        elif depth == 1:
            return count_moves(board)
        else:
            nodes = 0
            moves = board.legal_moves()
            for move in moves:
                board.apply(move)
                nodes += bullet_perft(board, depth - 1)
                board.undo()
            return nodes 








.. GENERATED FROM PYTHON SOURCE LINES 33-34

And in ``python-chess``

.. GENERATED FROM PYTHON SOURCE LINES 34-49

.. code-block:: Python


    import chess
    def chess_perft(board : chess.Board, depth : int) -> int:
        if depth == 0:
            return 1
        elif depth == 1:
            return board.legal_moves.count()
        else:
            nodes = 0
            for move in board.legal_moves:
                board.push(move)
                nodes += chess_perft(board, depth - 1)
                board.pop()
            return nodes
    







.. GENERATED FROM PYTHON SOURCE LINES 50-51

Notice how the code we write is nearly identical. However, when we test their run times:

.. GENERATED FROM PYTHON SOURCE LINES 51-67

.. code-block:: Python



    from time import time

    start = time()
    result = chess_perft(chess.Board(), 6)
    chess_time = time() - start
    print(f"chess_perft returned {result} in {chess_time:.4f}s")

    start = time()
    bullet_perft(bulletchess.Board(), 6)
    bullet_time = time() - start
    print(f"bullet_perft returned {result} in {bullet_time:.4f}s")

    print(f"bulletchess is {chess_time/bullet_time:.4f}x faster")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    chess_perft returned 119060324 in 108.5237s
    bullet_perft returned 119060324 in 1.5831s
    bulletchess is 68.5524x faster




.. GENERATED FROM PYTHON SOURCE LINES 68-70

We see a massive difference in ``bulletchess``'s move generation and application speed. 
``bulletchess`` is also very fast at writing and parsing FEN strings. 

.. GENERATED FROM PYTHON SOURCE LINES 70-76

.. code-block:: Python


    import json
    # JSON file with a list of 100k FENs
    with open("../data/fens.json", "r") as f:
        fens = json.load(f)








.. GENERATED FROM PYTHON SOURCE LINES 77-81

We can define FEN "roundtrip" functions in ``bulletchess`` and ``python-chess``,
which will make an object representing a position, then use that object to create a new FEN string,
which should match the original. Neither library stores the given FEN when a board object is created,
so both ``bulletchess`` and ``python-chess`` will fully parse and rewrite the input FENs.

.. GENERATED FROM PYTHON SOURCE LINES 81-93

.. code-block:: Python



    def bullet_roundtrip(fens : list[str]):
        boards = [bulletchess.Board.from_fen(fen)
                  for fen in fens]
        return [board.fen() for board in boards]


    def chess_roundtrip(fens : list[str]):
        boards = [chess.Board(fen) for fen in fens]
        return [board.fen(en_passant = "fen") for board in boards]








.. GENERATED FROM PYTHON SOURCE LINES 94-95

Similairly to before, we'll compare the runtimes of each version.

.. GENERATED FROM PYTHON SOURCE LINES 95-110

.. code-block:: Python


    start = time()
    chess_fens = chess_roundtrip(fens)
    chess_time = time() - start
    print(f"`chess_roundtrip` took {chess_time:.4}")

    start = time()
    bullet_fens = bullet_roundtrip(fens)
    bullet_time = time() - start
    print(f"`bullet_roundtrip` took {bullet_time:.4}")

    print(f"bulletchess is {chess_time/bullet_time:.4f}x faster")

    assert(chess_fens == bullet_fens)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    `chess_roundtrip` took 46.08
    `bullet_roundtrip` took 0.9638
    bulletchess is 47.8091x faster




.. GENERATED FROM PYTHON SOURCE LINES 111-113

And again, ``bulletchess`` is much faster. Using the same dataset of FENs, lets compare checking if positions
are checkmate, a draw, or ongoing. 

.. GENERATED FROM PYTHON SOURCE LINES 113-140

.. code-block:: Python



    def chess_statuses(boards : list[chess.Board]) -> dict:
        outcomes = {"ongoing": 0, "checkmate": 0, "draw": 0}
        for board in boards:
            outcome = board.outcome(claim_draw = True)
            if outcome == None:
                outcomes["ongoing"] += 1
            elif outcome.winner != None:
                outcomes["checkmate"] += 1
            else:
                outcomes["draw"] += 1
        return outcomes


    from bulletchess import CHECKMATE, DRAW
    def bullet_statuses(boards : list[bulletchess.Board]) -> dict:
        outcomes = {"ongoing": 0, "checkmate": 0, "draw": 0}
        for board in boards:
            if board in CHECKMATE:
                outcomes["checkmate"] += 1
            elif board in DRAW:
                outcomes["draw"] += 1
            else:
                outcomes["ongoing"] += 1
        return outcomes








.. GENERATED FROM PYTHON SOURCE LINES 141-143

The syntax of ``bulletchess`` and ``python-chess`` diverges more here,
but the structure is still the same. Running the comparison:

.. GENERATED FROM PYTHON SOURCE LINES 143-161

.. code-block:: Python


    chess_boards = [chess.Board(fen) for fen in fens]
    bullet_boards = [bulletchess.Board.from_fen(fen) for fen in fens]

    start = time()
    chess_res = chess_statuses(chess_boards)
    chess_time = time() - start
    print(f"`chess_statuses` took {chess_time:.4}")
    print(chess_res)

    start = time()
    bullet_res = bullet_statuses(bullet_boards)
    bullet_time = time() - start
    print(f"`bullet_statuses` took {bullet_time:.4}")
    print(bullet_res)

    print(f"bulletchess is {chess_time/bullet_time:.4f}x faster")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    `chess_statuses` took 110.6
    {'ongoing': 933861, 'checkmate': 40147, 'draw': 25992}
    `bullet_statuses` took 0.2974
    {'ongoing': 933861, 'checkmate': 40147, 'draw': 25992}
    bulletchess is 371.7527x faster





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (4 minutes 55.463 seconds)


.. _sphx_glr_download_auto_examples_performance.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: performance.ipynb <performance.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: performance.py <performance.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: performance.zip <performance.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
